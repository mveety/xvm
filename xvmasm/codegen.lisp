(in-package :xvmasm)

(defun reg-value-by-id (regid &optional (regs *reg-list*))
  (if (equal regs nil)
      nil
      (if (equal (getf (car regs) :name) regid)
	  (getf (car regs) :value)
	  (reg-value-by-id regid (cdr regs)))))

(defun reg-id-by-value (reg-value &optional (regs *reg-list*))
  (if (equal regs nil)
      nil
      (if (equal (getf (car regs) :value) reg-value)
	  (getf (car regs) :string)
	  (reg-id-by-value reg-value (cdr regs)))))

(defun generate-instruction-bytestream (inst)
  (let* ((instdef (get-instruction-def (getf inst :opcode)))
	 (opcode-field (getf instdef :opcode))
	 (lenmod-field 0)
	 (register-field 0)
	 (const-field 0)
	 (bytestream nil))
    (case (getf (getf inst :mods) :width)
      (word (setf lenmod-field 3))
      (halfword (setf lenmod-field 2))
      (byte (setf lenmod-field 1)))
    (case (getf (getf inst :mods) :mode)
      (absolute (setf (ldb (byte 1 2) lenmod-field) 1))
      (relative (setf (ldb (byte 1 3) lenmod-field) 1)))
    ;; remember length is the length of the args
    (setf (ldb (byte 4 4) lenmod-field) (- (getf inst :size) 2))
    (if (not (equal (getf (getf inst :args) :reg1) nil))
	(setf (ldb (byte 4 4) register-field)
	      (reg-value-by-id (cadr (getf (getf inst :args) :reg1)))))
    (if (not (equal (getf (getf inst :args) :reg2) nil))
	(setf (ldb (byte 4 0) register-field)
	      (reg-value-by-id (cadr (getf (getf inst :args) :reg2)))))
    (if (not (equal (getf (getf inst :args) :const) nil))
	(case (getf instdef :constarg)
	  (4 (setf const-field (le-u32int-to-byte
				(getf (getf inst :args) :const))))
	  (2 (setf const-field (le-u16int-to-byte
				(getf (getf inst :args) :const))))
	  (1 (setf const-field (le-u8int-to-byte
				(getf (getf inst :args) :const))))))
    (append-to-list bytestream lenmod-field)
    (append-to-list bytestream opcode-field)
    (if (getf instdef :reverse)
	(progn
	  (if (not (equal (getf instdef :constarg) 0))
	      (setf bytestream (append bytestream const-field)))
	  (if (not (equal (getf instdef :regargs) 0))
	      (append-to-list bytestream register-field)))
	(progn
	  (if (not (equal (getf instdef :regargs) 0))
	      (append-to-list bytestream register-field))
	  (if (not (equal (getf instdef :constarg) 0))
	      (setf bytestream (append bytestream const-field)))))
    bytestream))

(defun generate-stage2-bytestream (s2-inststream)
  (let* ((tmp nil)
	 (rval nil))
    (dolist (x s2-inststream)
      (cond
	((equal (car x) :opcode)
	 (setf tmp (generate-instruction-bytestream x)))
	((equal (car x) :data)
	 (setf tmp (getf x :data)))
	(t (error "invalid data in stage2 stream: ~a" (car x))))
      (setf rval (append rval tmp)))
    rval))
