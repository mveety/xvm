#define memread8 memread
#define memwrite8 memwrite

#define R0(c) (c->regs[0])
#define R1(c) (c->regs[1])
#define R2(c) (c->regs[2])
#define R3(c) (c->regs[3])
#define R4(c) (c->regs[4])
#define R5(c) (c->regs[5])
#define R6(c) (c->regs[6])
#define R7(c) (c->regs[7])
#define C0(c) (c->regs[8])
#define C1(c) (c->regs[9])
#define C2(c) (c->regs[10])
#define C3(c) (c->regs[11])
#define C4(c) (c->regs[12])
#define C5(c) (c->regs[13])
#define C6(c) (c->regs[14])
#define C7(c) (c->regs[15])
#define OP(c) (c->regs[8])
#define CP(c) (c->regs[9])
#define PC(c) (c->regs[10])
#define SP(c) (c->regs[11])
#define FP(c) (c->regs[12])
#define SV(c) (c->regs[13])
#define FV(c) (c->regs[14])
#define FL(c) (c->regs[15])

#define privmode(c) (c->regs[15] & (1<<0))
#define addrmode(c) (c->regs[15] & (1<<1))
#define intmode(c) (c->regs[15] & (1<<2))
#define testflag(c) (c->regs[15] & (1<<3))
#define intnumber(c) ((c->regs[15] & (0x0f << 4)) >> 4)
#define intflag(c) (c->regs[15] & (1<<8))
#define overflow(c) (c->regs[15] & (1<<9))

typedef struct Instdef Instdef;
typedef struct Inst Inst;
typedef struct RawInst RawInst;
typedef struct Cpu Cpu;

struct Instdef {
	u8int len;
	u8int mod1;
	u8int mod2;
	u8int opcode;	// if 0, then last definition
	u8int order;	// 1 if const then reg, 0 otherwise
	u8int regargsn; // 0 if no reg args
	u8int constargsz;	// 0 if no const args
};

struct Inst {
	u8int len;
	u8int width;
	u8int mode;
	u8int condition;
	u8int opcode;
	u8int usereg;
	u8int memwrite;
	u8int argregs[2];
	u32int argliteral;
};

struct RawInst {
	u8int len;
	u8int mods;
	u8int opcode;
	u8int args[16];
};

enum {
	regR0 = 0,
	regR1 = 1,
	regR2 = 2,
	regR3 = 3,
	regR4 = 4,
	regR5 = 5,
	regR6 = 6,
	regR7 = 7,
	regC0 = 8,
	regC1 = 9,
	regC2 = 10,
	regC3 = 11,
	regC4 = 12,
	regC5 = 13,
	regC6 = 14,
	regC7 = 15,
	regOP = 8,
	regCP = 9,
	regPC = 10,
	regSP = 11,
	regFP = 12,
	regSV = 13,
	regFV = 14,
	regFL = 15,
};

enum {
	FaultMem = 0,
	FaultInst = 1,
};

enum {
	ErrMem = -1,
	ErrSyscall = -2,
	ErrSysret = -3,
	ErrSoftInt = -4,
	ErrSoftIntRet = -5,
	ErrInvalidInst = -6,
	ErrUnableToInt = -99,
};

struct Cpu {
	u32int regs[16];					// the registers
	u32int nextpc;						// second PC for decoder
	u8int (*memread)(u32int);			// memory read
	void (*memwrite)(u32int, u8int);	// memory write
	int (*memtest)(u32int);				// check to see if memory is valid
	u32int (*devread)(u32int);			// device read
	void (*devwrite)(u32int, u32int);	// device write
	void (*devint)(u32int);				// device interrupt
	void (*hwint)(u8int);				// hardware interrupt
	void (*contint)(void);				// continuation interrupt
	u32int memmin;						// mem address space min
	u32int memmax;						// mem address space max
	u8int halted;						// is cpu halted?
	u8int doint;						// do an int flag
	u8int intn;							// int flag
};

// mem1.c
extern u32int addrdecode(Cpu*, u32int);
extern int memcheck(Cpu*, u32int, u32int);
extern int memread(Cpu*, u32int, u8int*);
extern int memwrite(Cpu*, u32int, u8int);
extern int memread16(Cpu*, u32int, u16int*);
extern int memwrite16(Cpu*, u32int, u16int);
extern int memread32(Cpu*, u32int, u32int*);
extern int memwrite32(Cpu*, u32int, u32int);

// dev1.c
extern u8int devread8(Cpu*, u32int);
extern u16int devread16(Cpu*, u32int);
extern u32int devread32(Cpu*, u32int);
extern void devint(Cpu*, u32int);
extern void devwrite8(Cpu*, u32int, u8int);
extern void devwrite16(Cpu*, u32int, u16int);
extern void devwrite32(Cpu*, u32int, u32int);

// insts.c (autogenerated)
extern Instdef instdefs[];

// decode.c
extern int fetch(Cpu*, RawInst*);
extern int decode(Cpu*, RawInst*, Inst*);

// exec1.c
extern void regfetch(Cpu*, Inst*, u32int*);
extern void regwrite(Cpu*, Inst*, u32int*);
extern int cpuexec1(Cpu*, Inst*);

// exec2.c
extern int cpuexec(Cpu*);

